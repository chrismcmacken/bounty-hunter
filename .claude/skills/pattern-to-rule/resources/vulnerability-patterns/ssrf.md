# SSRF Vulnerabilities Pattern Guide

Reference for writing Semgrep rules detecting Server-Side Request Forgery (CWE-918).

---

## Overview

SSRF allows attackers to make the server send requests to unintended destinations, potentially accessing internal services or cloud metadata.

**CWE:** CWE-918 - Server-Side Request Forgery

**Impact:**
- Access internal services (Redis, databases, admin panels)
- Cloud metadata theft (AWS/GCP/Azure credentials)
- Port scanning internal network
- Bypass firewalls/ACLs
- RCE via internal services

---

## High-Value SSRF Targets

### Cloud Metadata Endpoints
```
# AWS
http://169.254.169.254/latest/meta-data/
http://169.254.169.254/latest/user-data/
http://169.254.169.254/latest/meta-data/iam/security-credentials/

# GCP
http://metadata.google.internal/computeMetadata/v1/
http://169.254.169.254/computeMetadata/v1/

# Azure
http://169.254.169.254/metadata/instance
http://169.254.169.254/metadata/identity/oauth2/token
```

### Internal Services
```
http://localhost:6379/            # Redis
http://127.0.0.1:11211/           # Memcached
http://internal-admin:8080/       # Admin panels
http://elasticsearch:9200/        # Elasticsearch
http://consul:8500/               # Consul
```

---

## Python SSRF

### HTTP Client Sinks

```yaml
pattern-sinks:
  # requests library
  - pattern: requests.get($URL, ...)
  - pattern: requests.post($URL, ...)
  - pattern: requests.put($URL, ...)
  - pattern: requests.delete($URL, ...)
  - pattern: requests.patch($URL, ...)
  - pattern: requests.head($URL, ...)
  - pattern: requests.options($URL, ...)
  - pattern: requests.request($METHOD, $URL, ...)
  - pattern: $SESSION.get($URL, ...)
  - pattern: $SESSION.post($URL, ...)

  # urllib
  - pattern: urllib.request.urlopen($URL, ...)
  - pattern: urlopen($URL, ...)
  - pattern: urllib.request.Request($URL, ...)

  # urllib3
  - pattern: urllib3.request($METHOD, $URL, ...)
  - pattern: $POOL.request($METHOD, $URL, ...)

  # httpx
  - pattern: httpx.get($URL, ...)
  - pattern: httpx.post($URL, ...)
  - pattern: httpx.AsyncClient(...).get($URL, ...)
  - pattern: httpx.Client(...).get($URL, ...)

  # aiohttp
  - pattern: aiohttp.ClientSession(...).get($URL, ...)
  - pattern: aiohttp.ClientSession(...).post($URL, ...)
  - pattern: $SESSION.get($URL, ...)
```

### Sources (User Input)

```yaml
pattern-sources:
  # Flask
  - pattern: request.args.get(...)
  - pattern: request.args[...]
  - pattern: request.form.get(...)
  - pattern: request.form[...]
  - pattern: request.json.get(...)
  - pattern: request.json[...]

  # Django
  - pattern: request.GET.get(...)
  - pattern: request.GET[...]
  - pattern: request.POST.get(...)
  - pattern: request.POST[...]

  # FastAPI
  - pattern: $QUERY
  - pattern: $BODY
```

### Sanitizers

```yaml
pattern-sanitizers:
  # URL parsing (indicates validation attempt)
  - pattern: urlparse($URL).hostname
  - pattern: urllib.parse.urlparse($URL)

  # Allowlist check
  - pattern: |
      if $URL in $ALLOWED_URLS:
          ...
  - pattern: |
      if urlparse($URL).hostname in $ALLOWED_HOSTS:
          ...
```

---

## JavaScript/Node.js SSRF

### HTTP Client Sinks

```yaml
pattern-sinks:
  # axios
  - pattern: axios.get($URL, ...)
  - pattern: axios.post($URL, ...)
  - pattern: axios.put($URL, ...)
  - pattern: axios.delete($URL, ...)
  - pattern: axios.request({url: $URL, ...})
  - pattern: axios({url: $URL, ...})

  # fetch
  - pattern: fetch($URL, ...)
  - pattern: fetch($URL)

  # node-fetch
  - pattern: fetch($URL, ...)

  # got
  - pattern: got($URL, ...)
  - pattern: got.get($URL, ...)
  - pattern: got.post($URL, ...)

  # http/https modules
  - pattern: http.get($URL, ...)
  - pattern: https.get($URL, ...)
  - pattern: http.request($URL, ...)
  - pattern: https.request($URL, ...)

  # superagent
  - pattern: superagent.get($URL)
  - pattern: superagent.post($URL)

  # request (deprecated but common)
  - pattern: request($URL, ...)
  - pattern: request.get($URL, ...)
```

### Sources

```yaml
pattern-sources:
  # Express
  - pattern: req.query.$PARAM
  - pattern: req.body.$FIELD
  - pattern: req.params.$PARAM
  - pattern: req.query[...]
  - pattern: req.body[...]
```

---

## Java SSRF

### HTTP Client Sinks

```yaml
pattern-sinks:
  # HttpURLConnection
  - pattern: new URL($URL).openConnection()
  - pattern: (HttpURLConnection) new URL($URL).openConnection()
  - pattern: new URL($URL).openStream()

  # Apache HttpClient
  - pattern: new HttpGet($URL)
  - pattern: new HttpPost($URL)
  - pattern: $CLIENT.execute(new HttpGet($URL))

  # OkHttp
  - pattern: new Request.Builder().url($URL)

  # Spring RestTemplate
  - pattern: restTemplate.getForObject($URL, ...)
  - pattern: restTemplate.getForEntity($URL, ...)
  - pattern: restTemplate.postForObject($URL, ...)
  - pattern: restTemplate.exchange($URL, ...)

  # Spring WebClient
  - pattern: webClient.get().uri($URL)
  - pattern: webClient.post().uri($URL)

  # UriComponentsBuilder (CVE-2024-22259)
  - pattern: UriComponentsBuilder.fromUriString($URL)
  - pattern: UriComponentsBuilder.fromHttpUrl($URL)
```

### Sources

```yaml
pattern-sources:
  # Spring MVC
  - pattern: "@RequestParam(...) String $VAR"
  - pattern: "@PathVariable(...) String $VAR"
  - pattern: "@RequestBody $TYPE $VAR"
  - pattern: request.getParameter(...)
```

---

## Go SSRF

### HTTP Client Sinks

```yaml
pattern-sinks:
  # net/http
  - pattern: http.Get($URL)
  - pattern: http.Post($URL, ...)
  - pattern: http.NewRequest($METHOD, $URL, ...)
  - pattern: $CLIENT.Get($URL)
  - pattern: $CLIENT.Post($URL, ...)
  - pattern: $CLIENT.Do($REQ)  # If $REQ uses tainted URL
```

### Sources

```yaml
pattern-sources:
  # net/http
  - pattern: r.URL.Query().Get(...)
  - pattern: r.FormValue(...)
  - pattern: r.PostFormValue(...)

  # Gin
  - pattern: c.Query(...)
  - pattern: c.Param(...)
  - pattern: c.PostForm(...)
```

---

## PHP SSRF

### HTTP Client Sinks

```yaml
pattern-sinks:
  # cURL
  - pattern: curl_setopt($CH, CURLOPT_URL, $URL)
  - pattern: curl_init($URL)

  # file_get_contents (often overlooked!)
  - pattern: file_get_contents($URL, ...)

  # Guzzle
  - pattern: $CLIENT->get($URL, ...)
  - pattern: $CLIENT->post($URL, ...)
  - pattern: $CLIENT->request($METHOD, $URL, ...)

  # fopen (with URL wrappers)
  - pattern: fopen($URL, ...)
```

### Sources

```yaml
pattern-sources:
  - pattern: $_GET[...]
  - pattern: $_POST[...]
  - pattern: $_REQUEST[...]
  - pattern: $request->input(...)
  - pattern: $request->get(...)
```

---

## Taint Mode Pattern

```yaml
rules:
  - id: ssrf-detection
    mode: taint
    languages: [python]
    severity: ERROR
    message: |
      User-controlled URL passed to HTTP request. Validate against allowlist
      of permitted hosts/schemes to prevent SSRF.
    metadata:
      cwe: "CWE-918"
      owasp: "A10:2021 - Server-Side Request Forgery"
      confidence: HIGH

    pattern-sources:
      - pattern: request.args.get(...)
      - pattern: request.form[...]
      - pattern: request.json[...]

    pattern-sinks:
      - pattern: requests.get($URL, ...)
        focus-metavariable: $URL
      - pattern: requests.post($URL, ...)
        focus-metavariable: $URL
      - pattern: urllib.request.urlopen($URL, ...)
        focus-metavariable: $URL

    pattern-sanitizers:
      - pattern: |
          $PARSED = urlparse($URL)
          if $PARSED.hostname in $ALLOWED:
              ...
```

---

## URL Validation Bypasses

### IP Address Bypasses
```
http://127.0.0.1/
http://0.0.0.0/
http://[::1]/                    # IPv6 localhost
http://0177.0.0.1/               # Octal
http://2130706433/               # Decimal
http://0x7f.0x0.0x0.0x1/         # Hex
http://127.1/                    # Short form
```

### DNS Rebinding
```
# Attacker's DNS initially resolves to public IP
# After validation, resolves to 127.0.0.1
http://attacker.com/  → 1.2.3.4 (validates) → 127.0.0.1 (fetches)
```

### URL Parser Inconsistencies
```
http://evil.com#@safe.com        # Fragment confusion
http://safe.com@evil.com         # Credential confusion
http://safe.com\.evil.com        # Backslash confusion
```

### Protocol Smuggling
```
gopher://127.0.0.1:6379/_*1%0d%0a...   # Redis command injection
dict://127.0.0.1:6379/info              # DICT protocol
file:///etc/passwd                       # Local file read
```

---

## Test Case Template

```python
# test_ssrf.py

import requests
from flask import request

# === TRUE POSITIVES ===

# ruleid: ssrf-detection
def bad_direct_url():
    url = request.args.get('url')
    response = requests.get(url)
    return response.text

# ruleid: ssrf-detection
def bad_url_in_json():
    data = request.json
    response = requests.get(data['callback_url'])
    return response.text

# ruleid: ssrf-detection
def bad_partial_url():
    host = request.args.get('host')
    url = f'http://{host}/api/data'
    response = requests.get(url)
    return response.text

# === TRUE NEGATIVES ===

# ok: ssrf-detection
def good_hardcoded():
    response = requests.get('https://api.example.com/data')
    return response.text

# ok: ssrf-detection
def good_allowlist():
    url = request.args.get('url')
    parsed = urlparse(url)
    if parsed.hostname not in ['api.example.com', 'cdn.example.com']:
        return "Forbidden", 403
    response = requests.get(url)
    return response.text

# ok: ssrf-detection
def good_internal_only():
    # URL from database, not user input
    callback = get_webhook_url_from_db(user_id)
    response = requests.post(callback, json=data)
    return response.status_code
```

---

## CVE Examples

### CVE-2024-39338 (Axios)
Path-relative URL handling in Axios allowed SSRF via specially crafted URLs.

### CVE-2024-22259 (Spring)
UriComponentsBuilder could be tricked into building URLs to unintended hosts.

### Detection focus:
- Framework-specific URL parsing
- URL construction from user input
- Protocol handlers (file://, gopher://)
