# CVE Root Cause Analysis Checklist

Step-by-step template for analyzing CVEs and extracting patterns for Semgrep rules.

---

## Phase 1: CVE Information Gathering

### 1.1 Fetch CVE Details

- [ ] **CVE ID**: CVE-____-______
- [ ] **CVSS Score**: _____ (Critical/High/Medium/Low)
- [ ] **CWE Classification**: CWE-____

**Data Sources:**
```bash
# NVD (National Vulnerability Database)
curl -s "https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=CVE-YYYY-NNNNN" | jq

# OSV.dev (Open Source Vulnerabilities)
curl -s "https://api.osv.dev/v1/vulns/CVE-YYYY-NNNNN" | jq

# GitHub Advisory Database
gh api /advisories?cve_id=CVE-YYYY-NNNNN
```

### 1.2 Identify Affected Software

- [ ] **Package/Library**: _____________
- [ ] **Affected Versions**: _____________
- [ ] **Fixed Version**: _____________
- [ ] **Language/Ecosystem**: _____________

### 1.3 Locate the Patch

- [ ] **Repository URL**: _____________
- [ ] **Fix Commit**: _____________
- [ ] **PR/Issue Link**: _____________

```bash
# Search GitHub for fixing commits
gh search code "CVE-YYYY-NNNNN" --limit 10
gh search code "fix CVE-YYYY" --repo owner/repo
```

---

## Phase 2: Patch Analysis

### 2.1 Examine the Diff

- [ ] Download/view the patch diff
- [ ] Identify files changed
- [ ] Note lines added/removed

```bash
# View commit diff
git show <commit-hash>

# Or via GitHub API
gh api repos/owner/repo/commits/<commit-hash>
```

### 2.2 Root Cause Identification

Answer these questions:

**What was the vulnerable code doing?**
```
[Describe the vulnerable behavior]
```

**What type of input triggered the vulnerability?**
- [ ] User-controlled string
- [ ] User-controlled integer/number
- [ ] User-controlled object/dictionary
- [ ] File path/name
- [ ] URL/network destination
- [ ] Serialized data
- [ ] Environment variable
- [ ] Other: _____________

**Where did the untrusted input originate?**
- [ ] HTTP request parameter
- [ ] HTTP header
- [ ] HTTP body/JSON
- [ ] File upload
- [ ] Database query result
- [ ] Configuration file
- [ ] Command line argument
- [ ] Other: _____________

**What dangerous operation was reached?**
- [ ] SQL query execution
- [ ] Command/shell execution
- [ ] File system operation
- [ ] Deserialization
- [ ] Template rendering
- [ ] HTTP request (SSRF)
- [ ] Memory operation
- [ ] Crypto operation
- [ ] Other: _____________

### 2.3 Document the Vulnerable Pattern

**Vulnerable code snippet:**
```
[Paste vulnerable code here]
```

**Fixed code snippet:**
```
[Paste fixed code here]
```

**What changed in the fix?**
- [ ] Input validation added
- [ ] Input sanitization added
- [ ] Parameterized query used
- [ ] Safe API replacement
- [ ] Type checking added
- [ ] Access control added
- [ ] Other: _____________

---

## Phase 3: Pattern Extraction

### 3.1 Identify the Sink (Dangerous Function)

**Primary sink:**
```
[Function/method that causes harm when given tainted input]
```

**Alternative sinks (same vulnerability type):**
```
[Other functions that could be exploited similarly]
```

### 3.2 Identify the Source (User Input)

**Primary source in CVE:**
```
[Where untrusted data enters in this specific CVE]
```

**Generic sources (for broader rule):**
```
[Common entry points for this input type in various frameworks]
```

### 3.3 Identify Sanitizers

**What makes the input safe?**
```
[Functions/operations that neutralize the threat]
```

### 3.4 Choose Rule Mode

- [ ] **Pattern mode** - Simple syntactic match
  - Use when: Single dangerous function call with specific arguments
  - Example: `eval(user_input)`

- [ ] **Taint mode** - Data flow tracking
  - Use when: Input flows through multiple steps before reaching sink
  - Example: User input → variable → string concat → SQL query

- [ ] **Pattern-either** - Multiple variants
  - Use when: Several syntactic patterns indicate same vulnerability
  - Example: `exec()`, `system()`, `popen()` all indicate command injection

---

## Phase 4: Variant Analysis

### 4.1 Pattern Variants

Consider variations attackers might use:

- [ ] Different function names with same behavior
- [ ] Different argument positions
- [ ] Different string construction methods (concat, f-string, format)
- [ ] Framework-specific equivalents
- [ ] Async/await versions

### 4.2 Insufficient Patch Analysis

Check if the patch was complete:

- [ ] Does the fix cover all code paths?
- [ ] Does the fix handle all input types?
- [ ] Can the sanitization be bypassed?
- [ ] Are there similar patterns elsewhere in codebase?

**Questions to ask:**
1. What if the input comes from a different source?
2. What if the input is in a different format?
3. What if there's a race condition?
4. What if encoding/decoding changes the input?

### 4.3 Regression Hunting

- [ ] Was this vulnerability fixed before and reintroduced?
- [ ] Check git history for similar patterns
- [ ] Search for TODO/FIXME comments about security

```bash
# Search for similar patterns in history
git log -p --all -S "dangerous_function"
git log --all --grep="security" --grep="fix"
```

---

## Phase 5: Rule Quality Gates

Before finalizing the rule, verify it passes these quality gates (from Autogrep research):

### 5.1 Syntactic Validity
- [ ] Rule YAML is valid
- [ ] Pattern syntax is correct
- [ ] Languages are specified correctly

```bash
semgrep --validate --config rule.yaml
```

### 5.2 Semantic Validity
- [ ] Pattern matches vulnerable code
- [ ] Pattern does NOT match fixed code
- [ ] Taint sources are reachable
- [ ] Taint sinks receive tainted data

### 5.3 Effectiveness Check
- [ ] Rule finds the original CVE vulnerability
- [ ] Rule finds at least one variant
- [ ] False positive rate < 20%

### 5.4 Test File Coverage
- [ ] At least 3 true positive test cases (ruleid:)
- [ ] At least 3 true negative test cases (ok:)
- [ ] Edge cases documented

---

## Phase 6: Documentation Template

Fill this out for the rule's `message` and metadata:

```yaml
message: |
  [One sentence describing what was detected]

  This pattern is similar to CVE-YYYY-NNNNN which affected [package].

  **Impact**: [What an attacker can do]

  **Remediation**: [How to fix]

metadata:
  cve: "CVE-YYYY-NNNNN"
  cwe: "CWE-XX"
  owasp: "A0X:2021 - [Category]"
  confidence: HIGH  # HIGH if taint mode, MEDIUM if pattern only
  category: security
  references:
    - https://nvd.nist.gov/vuln/detail/CVE-YYYY-NNNNN
    - [Link to patch]
    - [Link to writeup if available]
```

---

## Quick Reference: CWE to Vulnerability Type

| CWE | Vulnerability | Typical Sink |
|-----|---------------|--------------|
| CWE-78 | Command Injection | os.system, subprocess, exec |
| CWE-79 | XSS | innerHTML, document.write, template |
| CWE-89 | SQL Injection | cursor.execute, query, raw |
| CWE-94 | Code Injection | eval, exec, compile |
| CWE-98 | LFI/RFI | include, import_module, open |
| CWE-200 | Information Disclosure | log, print, response |
| CWE-22 | Path Traversal | open, read, write, os.path.join |
| CWE-352 | CSRF | form submission without token |
| CWE-502 | Deserialization | pickle, yaml.load, unserialize |
| CWE-611 | XXE | parse, parseString, DocumentBuilder |
| CWE-918 | SSRF | requests.get, fetch, urlopen |
| CWE-1336 | SSTI | render_template_string, Template |

---

## Example: Completed Checklist

**CVE-2024-6386 (WPML Twig SSTI)**

- [x] CVE ID: CVE-2024-6386
- [x] CVSS: 9.9 (Critical)
- [x] CWE: CWE-1336

**Root Cause:**
- User input from translation shortcode passed directly to Twig template engine
- `$twig->createTemplate($user_controlled_content)` was the sink

**Pattern:**
```yaml
pattern-sinks:
  - pattern: $twig->createTemplate($TEMPLATE)
```

**Variants identified:**
1. Direct createTemplate call
2. createTemplate with additional args
3. Twig Environment from_string equivalent

**Quality gates:**
- [x] Validates successfully
- [x] Catches vulnerable WPML code
- [x] Doesn't fire on safe template file loading
- [x] Test file created with ruleid/ok annotations
