# CVE-to-Semgrep Rule Workflow

Create custom Semgrep rules from CVE patches to find 0-day variants in bug bounty targets.

## Overview

**Variant analysis** is a proven technique used by security researchers at Google Project Zero, GitHub Security Lab, and others:

1. CVE reveals a vulnerability class
2. Patch shows what code pattern was vulnerable
3. Semgrep rule encodes that pattern
4. Scan at scale finds the same mistake elsewhere

## Quick Start: Use the Skills

```bash
# Discover CVEs suitable for rule creation
/discover-cves pypi                    # Recent Python CVEs
/discover-cves npm --critical          # Critical Node.js CVEs
/discover-cves --org acme-corp         # CVEs in target's dependencies

# Create a rule from a CVE
/cve-to-rule CVE-2024-XXXXX

# Test the rule against known vulnerable apps
/test-semgrep-rule custom-rules/cve/CVE-2024-XXXXX.yaml
```

---

## Workflow

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  0. Discover    │────▶│  1. Find CVE    │────▶│  2. Get Patch   │
│ /discover-cves  │     │  (Pick from     │     │  (GitHub diff)  │
│                 │     │   candidates)   │     │                 │
└─────────────────┘     └─────────────────┘     └─────────────────┘
                                                       │
┌─────────────────┐     ┌─────────────────┐           ▼
│  5. Hunt        │◀────│  4. Validate    │◀────┌─────────────────┐
│  (Scan Targets) │     │  (Quality Gates)│     │  3. Write Rule  │
└─────────────────┘     └─────────────────┘     │  /cve-to-rule   │
        │                                       └─────────────────┘
        ▼
┌─────────────────┐
│  6. Report      │
│  (Bug Bounty)   │
└─────────────────┘
```

---

## Step 0: Discover CVE Candidates

Use the `/discover-cves` skill to find CVEs suitable for rule creation.

### By Ecosystem (Recent High-Severity)

```bash
/discover-cves pypi                    # Python - last 30 days, CVSS >= 7.0
/discover-cves npm                     # Node.js
/discover-cves maven                   # Java
/discover-cves go                      # Go

/discover-cves pypi --critical         # CVSS >= 9.0 only
/discover-cves pypi --days 90          # Last 90 days
```

### By Package

```bash
/discover-cves --package jinja2        # All CVEs for jinja2
/discover-cves --package lodash@npm    # Specific ecosystem
```

### By Target Dependencies

```bash
/discover-cves --org acme-corp         # CVEs in org's SBOM dependencies
```

### By Vulnerability Type

```bash
/discover-cves --cwe CWE-89            # SQL injection
/discover-cves --cwe CWE-502           # Deserialization
```

The skill scores each CVE for rule suitability:
- **+3**: Has fix commit
- **+3**: Pattern-matchable CWE (injection, SSRF, etc.)
- **+2**: Supported language (Python, Java, JS, etc.)
- **+1**: Recent (< 2 years)
- **+1**: Critical CVSS (>= 9.0)

Candidates with score >= 5 are highlighted.

---

## Step 1: Identify Target CVE

### Best Sources

| Source | URL | Notes |
|--------|-----|-------|
| OSV.dev | https://osv.dev | Best for commit links |
| GitHub Advisories | https://github.com/advisories | Good for GitHub repos |
| NVD | https://nvd.nist.gov | Official CVE database |
| Snyk DB | https://security.snyk.io | Good descriptions |

### Selection Criteria

**Good candidates:**
- Has public patch/commit
- Pattern-matchable vulnerability class
- Affects popular libraries (more variants likely)
- Recent (< 2 years) - patterns still in use

**Poor candidates:**
- Logic bugs requiring deep context
- Race conditions
- Memory corruption (use CodeQL)
- Requires runtime state analysis

---

## Step 2: Get the Patch

### Using cve-rule-helper.sh

```bash
# Fetch CVE details and find patch
./scripts/cve-rule-helper.sh CVE-2024-XXXXX

# Generate rule template
./scripts/cve-rule-helper.sh CVE-2024-XXXXX --template

# Analyze specific commit directly
./scripts/cve-rule-helper.sh owner/repo abc123def
```

### Manual Patch Retrieval

```bash
# Via GitHub API
gh api repos/OWNER/REPO/commits/COMMIT_SHA | jq '.files[].patch'

# Via git
git show COMMIT_SHA --format="" -- "*.py"

# Via GitHub web
# https://github.com/OWNER/REPO/commit/COMMIT_SHA.diff
```

---

## Step 3: Root Cause Analysis

Use the `/cve-to-rule` skill's checklist or analyze manually:

### Extract Key Elements

1. **Vulnerable pattern** - The "before" code
2. **Fix pattern** - The "after" code
3. **Context** - Function signatures, imports, variable names
4. **Trigger conditions** - What makes it exploitable

### Identify Components for Taint Rules

| Component | Question | Example |
|-----------|----------|---------|
| **Source** | Where does untrusted data enter? | `request.args.get(...)` |
| **Sink** | What dangerous operation is reached? | `cursor.execute($Q)` |
| **Sanitizer** | What makes the data safe? | `int(...)`, parameterized query |

### Example Analysis

**CVE-2024-XXXXX: Path Traversal in file handler**

```diff
- filepath = os.path.join(base_dir, user_input)
+ filepath = os.path.join(base_dir, os.path.basename(user_input))
```

**Source:** User input from request
**Sink:** `os.path.join(base, user_controlled)` without basename
**Sanitizer:** `os.path.basename()` strips path components

---

## Step 4: Write Semgrep Rule

### Rule Location

```
custom-rules/cve/
├── CVE-2024-XXXXX.yaml      # Rule file
├── CVE-2024-XXXXX.py        # Test cases
└── ...
```

### Use the Template

Copy from `.claude/skills/cve-to-rule/templates/cve-rule-template.yaml`

### Pattern Types

| Type | Use Case | Example |
|------|----------|---------|
| `mode: taint` | Injection/data flow | User input → dangerous function |
| `pattern` | Exact match | `eval($X)` |
| `pattern-either` | Multiple variants | `pickle.loads($X)` OR `pickle.load($X)` |
| `pattern-not` | Exclude safe patterns | Not `eval(CONSTANT)` |
| `pattern-inside` | Context requirement | Inside function handling user input |

### Best Practices

1. **Prefer taint mode** for injection vulnerabilities
2. **Add comprehensive sanitizers** to reduce false positives
3. **Cover multiple frameworks** (Flask, Django, FastAPI, etc.)
4. **Use focus-metavariable** to pinpoint the vulnerable parameter
5. **Exclude test directories** to reduce noise

---

## Step 5: Validate Rule (Quality Gates)

**Research shows 82% of auto-generated rules are rejected** (Autogrep 2025). Apply these quality gates:

### 5.1 Syntactic Validity
```bash
semgrep --validate --config custom-rules/cve/CVE-2024-XXXXX.yaml
```

### 5.2 Semantic Validity - Catch Vulnerable Code
```bash
# Clone vulnerable version
git clone https://github.com/owner/repo
cd repo && git checkout VULNERABLE_COMMIT^

# Verify rule catches it
semgrep --config ../custom-rules/cve/CVE-2024-XXXXX.yaml .
# Expected: >= 1 finding at vulnerable location
```

### 5.3 No Regression - Don't Catch Fixed Code
```bash
# Checkout fixed version
git checkout FIXED_COMMIT

# Verify fix is not flagged
semgrep --config ../custom-rules/cve/CVE-2024-XXXXX.yaml .
# Expected: 0 findings (or fewer than before)
```

### 5.4 Test File Coverage
```bash
# Create test file with annotations
# At least 3 ruleid: (true positives)
# At least 3 ok: (true negatives)

# Run tests
semgrep --test custom-rules/cve/
```

### 5.5 False Positive Check
```bash
# Run against real codebase
semgrep --config custom-rules/cve/CVE-2024-XXXXX.yaml repos/<org>/ --json > results.json

# Count and review findings
jq '.results | length' results.json

# Target: < 20% false positive rate
```

---

## Step 6: Three Avenues of Variant Hunting

After creating a rule, hunt for variants using three approaches:

### Avenue 1: Pattern Variants

Look for different ways to construct the same vulnerable pattern:

```python
# Original CVE pattern
cursor.execute("SELECT * FROM users WHERE id=" + user_id)

# Variants to detect:
cursor.execute(f"SELECT * FROM users WHERE id={user_id}")
cursor.execute("SELECT * FROM users WHERE id={}".format(user_id))
cursor.execute("SELECT * FROM users WHERE id=%s" % user_id)
```

### Avenue 2: Insufficient Patch Analysis

Check if the original fix was complete:

- Does the fix cover ALL code paths?
- Does it handle ALL input types?
- Can the sanitization be bypassed?
- Are there similar patterns in other files?

### Avenue 3: Regression Hunting

Look for historical patterns:

```bash
# Search for similar patterns in git history
git log -p --all -S "dangerous_function"

# Check for security-related commits that might have been reverted
git log --all --grep="security" --grep="fix"
```

---

## Step 7: Hunt and Report

### Scan Bug Bounty Targets

```bash
# Scan specific org with new rule
semgrep --config custom-rules/cve/CVE-2024-XXXXX.yaml repos/<org>/

# Scan all targets with all CVE rules
semgrep --config custom-rules/cve/ repos/*/

# Or use full scan (includes CVE rules automatically)
./scripts/catalog-scan.sh <org>
```

### Triage Findings

Use the review skill:
```bash
/review-semgrep <org>
```

### Verify Findings

1. **Reachability** - Is the vulnerable code path accessible?
2. **Exploitability** - Can you trigger the vulnerability?
3. **Impact** - What's the real-world consequence?

### Report Template

```markdown
## Summary
Variant of CVE-2024-XXXXX found in [component].

## Vulnerability Details
- **Type**: [Path Traversal / SQLi / etc.]
- **CWE**: CWE-XX
- **Location**: `src/handlers/file.py:42`
- **Original CVE**: CVE-2024-XXXXX

## Reproduction Steps
1. ...
2. ...
3. ...

## Proof of Concept
[Code/curl command demonstrating the issue]

## Impact
[What an attacker can achieve]

## Recommendation
[How to fix, referencing the original CVE fix]
```

---

## CVE Suitability by Category

| Category | Suitability | Notes |
|----------|-------------|-------|
| SQL Injection | Excellent | String concat in queries |
| Command Injection | Excellent | User input to subprocess |
| Path Traversal | Excellent | Unsanitized path operations |
| XSS | Good | innerHTML, template injection |
| Deserialization | Good | pickle, yaml.load, JSON.parse with reviver |
| SSRF | Good | User-controlled URLs |
| XXE | Good | XML parser configuration |
| SSTI | Good | Template from string |
| Auth Bypass | Moderate | Missing decorators/middleware |
| IDOR | Moderate | Missing ownership checks |
| Race Conditions | Poor | Needs dynamic analysis |
| Memory Corruption | Poor | Use CodeQL instead |
| Cryptographic | Poor | Often context-dependent |

---

## Skill Integration

### `/cve-to-rule`

Full workflow for creating rules from CVEs:
1. Fetches CVE details from NVD/OSV.dev
2. Locates and analyzes patch
3. Checks existing rule coverage
4. Generates taint-mode rule with sanitizers
5. Creates test file with annotations
6. Validates rule passes quality gates

**Resources available:**
- Semgrep documentation (full + summarized)
- Existing rules summary
- CVE analysis checklist
- False positive patterns
- Vulnerability-specific guides
- Good/bad rule examples
- Templates

### `/test-semgrep-rule`

Evaluate rules against known vulnerable applications:
1. Sets up test environment (Docker/clone)
2. Runs rule against vulnerable code
3. Classifies findings (TP/FP/FN)
4. Calculates metrics (precision, recall, FP rate)
5. Generates evaluation report
6. Recommends confidence level

**Test repositories:**
- OWASP WebGoat (Java)
- OWASP Benchmark (standardized metrics)
- DVWA (PHP)
- Juice Shop (Node.js)
- PyGoat (Python)
- RailsGoat (Ruby)

---

## Resources

### CVE Databases
- [OSV.dev](https://osv.dev) - Best for finding fix commits
- [GitHub Advisories](https://github.com/advisories) - GitHub ecosystem
- [NVD](https://nvd.nist.gov) - Official CVE database
- [Snyk Vulnerability DB](https://security.snyk.io) - Good descriptions

### Semgrep References
- [Semgrep Registry](https://semgrep.dev/r) - Existing rules for inspiration
- [Semgrep Docs](https://semgrep.dev/docs/) - Rule syntax reference
- [Semgrep Playground](https://semgrep.dev/playground) - Test rules online

### Research
- [Autogrep (2025)](https://lambdasec.github.io/AutoGrep-Automated-Generation-and-Filtering-of-Semgrep-Rules-from-Vulnerability-Patches/) - LLM rule generation, 82% rejection rate
- [Semgrep Variant Analysis](https://semgrep.dev/blog/2025/finding-more-zero-days-through-variant-analysis/) - Official variant hunting guide
- [OWASP Benchmark](https://owasp.org/www-project-benchmark/) - Standardized testing

### Example CVE Rules
- [Trail of Bits Semgrep Rules](https://github.com/trailofbits/semgrep-rules)
- [Returntocorp Community Rules](https://github.com/returntocorp/semgrep-rules)

---

## Language Priority

Use inventory data to prioritize which languages to write rules for:

```bash
./scripts/extract-inventory.sh <org> languages
```

Focus on languages with the most code across your targets.
